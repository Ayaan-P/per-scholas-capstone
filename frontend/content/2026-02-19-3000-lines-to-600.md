---
title: "How We Refactored 3,000 Lines of Code to 600"
date: "2026-02-19"
description: "Our backend main.py grew out of control. Here's how we split it into a maintainable architecture without breaking anything."
tags: ["engineering", "python", "refactoring", "fastapi"]
---

Every codebase has that file. The one that started small, grew organically, and eventually became a 3,000-line monster that nobody wants to touch. For FundFish, that file was `main.py`.

## How We Got Here

When we first built FundFish, speed mattered more than architecture. We were validating the idea: could AI actually help nonprofits find grants? So we did what any scrappy startup does — we shipped fast.

Routes got added to `main.py`. Then more routes. Then helper functions. Then services that "temporarily" lived in the same file. Before we knew it, we had a 3,097-line behemoth handling:

- Health checks and scheduler management
- Organization configuration and authentication
- Grant scraping and opportunity matching
- Proposal generation and document handling
- Dashboard analytics and user management
- RFP parsing and AI scoring

Finding anything was a nightmare. A simple "where does this endpoint live?" required Ctrl+F and prayer.

## The Breaking Point

The refactor didn't happen because we had time. It happened because we had to add the agentic features — AI agents that could chat with users, write proposals, and discover grants autonomously. Bolting that onto a 3,000-line file? No way.

So we made a decision: extract routes incrementally, one domain at a time, without breaking production.

## The Strategy

Here's what worked:

### 1. Extract by Domain, Not by Size

We didn't just chop the file into random chunks. We identified logical domains:

- `routes/health.py` — Health checks, scheduler control
- `routes/categories.py` — Grant category management  
- `routes/dashboard.py` — User dashboard data
- `routes/organization.py` — Org config, auth, documents
- `routes/proposals.py` — Proposal CRUD and generation
- `routes/grants.py` — Grant management endpoints
- `routes/rfps.py` — RFP parsing and handling
- `routes/opportunities.py` — Opportunity matching and scoring

Each extraction followed the same pattern:
1. Create the new file with the router
2. Move related routes
3. Update imports
4. Test locally
5. Deploy and verify

### 2. Keep Shared Dependencies Central

The temptation was to move everything. But some things genuinely belonged in `main.py`:

- Supabase client initialization
- Auth middleware setup
- CORS configuration
- Application startup/shutdown events

These stayed in `main.py`, imported by the route modules.

### 3. One PR Per Domain

We could have done one massive PR. That would have been a terrible idea. Instead:

- **Commit 77fe2a3**: Health, categories, scheduler, dashboard → `-281 lines`
- **Commit 8a365d1**: Organization routes → `-669 lines`
- **Commit f92d210**: Proposals → `-342 lines`
- **Commit 5b5c8ce**: Grants → `-183 lines`
- **Commit 373b4ab**: RFPs → `-155 lines`
- **Commit d2fc3e0**: Opportunities → `-874 lines`

Each commit was deployed independently. If something broke, we knew exactly where to look.

## The Results

**Before:** 3,097 lines in `main.py`  
**After:** 601 lines in `main.py`

That's an **81% reduction**. The remaining code handles:
- Application setup and configuration
- Middleware and CORS
- Router registration
- Startup/shutdown hooks
- A few utility endpoints that didn't fit elsewhere

More importantly, the codebase became navigable. Need to debug proposal generation? Check `routes/proposals.py`. Grant matching acting weird? `routes/opportunities.py`. No more scrolling through thousands of lines.

## Lessons Learned

**1. Refactoring is easier than you think**

Once we started, it went fast. The hard part was deciding to do it.

**2. Tests make everything safer**

We had basic endpoint tests. They caught three regressions during the refactor. Worth every minute spent writing them.

**3. Domain extraction beats file-size extraction**

Splitting by logical domain means new features have an obvious home. Splitting by file size just creates smaller chaos.

**4. Don't wait for the perfect moment**

We refactored while actively shipping features. The agentic pivot happened *during* this work. Waiting would have made both harder.

## What's Next

With a clean architecture, we're shipping faster than ever:

- Agent infrastructure is live
- Document uploads work end-to-end
- Scoring agents can load org profiles from the database
- The dashboard shows personalized grant matches

The refactor wasn't the goal — it was the foundation. Now we can build the real product.

---

*FundFish is AI-powered fundraising for nonprofits. We help organizations find grants, write proposals, and raise more money. [Try it free →](/signup)*
